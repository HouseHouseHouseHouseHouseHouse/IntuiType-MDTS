%!PS

% Convert Inches to Points
% in --> pt
/in { 72 mul } def

/PageWidth 8.5 in def
/PageHeight 11 in def

/MarginX 1 in def
/MarginY 1 in def
/Indent 0.5 in def

/FontHeight 16 def
/Leading 0.15 def

/pageLine 0 def

% TODO - Paragraph Routine (keep in mind single-line paragraphs)
% TODO - Handle Overflow into Another Page

% TODO - Additional Formatting Things - Lists, Blockquotes, Code Blocks etc.
% TODO - Columns, Rules, Page Breaks

% TODO (maybe) - Space out Err throughout All Chars (single-word lines)
% TODO (maybe) - Special Things for Dashes and other Word Separators
% TODO (maybe) - Higher-Order Indentation (use integer as indent parameter)

% TODO - Make a Program to Generate this Document from Plaintext (maybe keep in res/ but no example, use fancy comments)

% Calculate a Line of Words
% BASE [/f] (word1)..[/f] (wordX) indent --> BASE [/f] (wordN+1)..[/f] (wordX) /f (word1)../f (wordN) N width final
%
% The entire stack should be the remaining words in a paragraph,
% starting at the base, with optional font names below each
% word. Words that will fit in one line will be placed at the
% top and a font name will be specified for each.
/CalcLine {

    /curLineWidth 0 def                                         % [/f] (word1)..[/f] (wordX) indent
    /curLineWords 0 def
    /nxtLineWidth 0 def

    /maxLineWidth PageWidth MarginX 2 mul sub                   % [/f] (word1)..[/f] (wordX) indent /v width        Maximum line width
    2 index { Indent sub } if def pop                           % [/f] (word1)..[/f] (wordX)                        Account for indent if necessary

    0                                                           % [/f] (word1)..[/f] (wordX) 0      Mark the end of the paragraph

    /curFontFace /Times-Roman def

    {

        /final true def                                         % [/f] (cur)../f (pre)              If we exit, this is the final line

        count -1 roll                                           % ../f (pre) [(cur) OR /f OR 0]     Bring up current word, next font name, or end mark

        dup 0 eq { count 1 roll exit } if                       % ../f (pre) [(cur) OR /f]          If this is the end mark, replace it and exit

        dup type /nametype eq {
                                                                % (cur) [/f] (nxt)../f (pre) /f
            /curFontFace exch def                               % (cur) [/f] (nxt)../f (pre)        If this is a font name, set variable
            count -1 roll                                       % [/f] (nxt)../f (pre) (cur)        Bring up current word
        } if
        curFontFace exch                                        % [/f] (nxt)../f (pre) /f (cur)     Bury current font for print routine
        curFontFace findfont FontHeight scalefont setfont       % [/f] (nxt)../f (cur)              Set word font

        /final false def                                        % [/f] (nxt)../f (cur)              If we exit, this isn't the final line

        dup stringwidth pop nxtLineWidth add                    % [/f] (nxt)../f (cur) width        Width of line including this word
        dup maxLineWidth gt { pop count 2 roll exit } if        % [/f] (nxt)../f (cur) width        If word doesn't fit, stop here
        /curLineWidth exch def                                  % [/f] (nxt)../f (cur)              Otherwise, add to width
        /curLineWords curLineWords 1 add def                    % [/f] (nxt)../f (cur)              Increment word counter

        /nxtLineWidth ( ) stringwidth pop curLineWidth add def  % [/f] (nxt)../f (cur)              Width of line including this word with whitespace
        nxtLineWidth maxLineWidth ge { exit } if                % [/f] (nxt)../f (cur)              If whitespace doesn't fit, stop here

    } loop

                                                                % [/f] (wordN+1)..[/f] (wordX) 0 /f (word1)../f (wordN)
    curLineWords 2 mul 1 add -1 roll pop                        % [/f] (wordN+1)..[/f] (wordX) /f (word1)../f (wordN)
    curLineWords curLineWidth final                             % [/f] (wordN+1)..[/f] (wordX) /f (word1)../f (wordN) N width final

} def

% Print a Line of Words 
% /f (word1)../f (wordN) N width justify indent --> -
%
% The stack should contain a font name for every word in the line.
% All words will be printed onto the current line, and the line will
% be advanced.
/PrintLine {

                                                                % /f (word1)../f (wordN) N width justify indent
    exch 1 index                                                % /f (word1)../f (wordN) N width indent justify indent
    MarginX exch { Indent add } if                              % /f (word1)../f (wordN) N width indent justify x                       Start at left margin and indent if necessary
    PageHeight MarginY sub pageLine                             % /f (word1)../f (wordN) N width indent justify x top line              Top margin and line number
    FontHeight Leading 1 add mul                                % /f (word1)../f (wordN) N width indent justify x top line spacing      Spacing per line
    mul FontHeight add sub                                      % /f (word1)../f (wordN) N width indent justify x y                     Point of line from the top (pointer is bottom of line)
    moveto                                                      % /f (word1)../f (wordN) N width indent justify                         Move pointer

    /err 0 def
    {

        PageWidth MarginX 2 mul sub                             % /f (word1)../f (wordN) N width indent maxWidth      Maximum width
        exch { Indent sub } if                                  % /f (word1)../f (wordN) N width maxWidth             Account for indent if necessary
        exch sub                                                % /f (word1)../f (wordN) N balance                    Amount of space remaining
        1 index 1 sub div                                       % /f (word1)../f (wordN) N err                        Points to add to whitespace
        /err exch def                                           % /f (word1)../f (wordN) N

    } { pop pop } ifelse                                        % /f (word1)../f (wordN) N          Compute err if we should justify, ensure width and indent are discarded

    -1 1 {

                                                                % /f (cur)../f (wordN) i                i = words remaining
        dup 2 mul 1 add -2 roll                                 % /f (nxt)../f (wordN) i /f (cur)       Bring up current word or next font name
        exch findfont FontHeight scalefont setfont              % /f (nxt)../f (wordN) i (cur)          Set word font
        show                                                    % /f (nxt)../f (wordN) i                Print current word

        1 gt { err 0 ( ) ashow } if                             % /f (nxt)../f (wordN)                  If there are more words, print whitespace with extra points

    } for                                                       %                                   Loop through all words

    /pageLine pageLine 1 add def                                %                                   Next time, next line

} def

% Print a Paragraph
% BASE /f (word1) [/f] (word2)..[/f] (wordX) -> BASE -
%
% The stack should consist of only the words in the paragraph.
% Words are individual strings optionally preceded by a font
% name. The first word is at the base of the stack and it must
% have a font name.
/PrintParagraph {

    /first true def                                             % /f (word1)..[/f] (wordX)          This is the first line
    {

        first CalcLine                                          % [/f] (wordN+1)..[/f] (wordX) /f (word1)../f (wordN) N width final                     Calculate a line
        dup not exch first exch                                 % [/f] (wordN+1)..[/f] (wordX) /f (word1)../f (wordN) N width justify indent final      Set up printing parameters and condition
        { PrintLine exit } if                                   % [/f] (wordN+1)..[/f] (wordX) /f (word1)../f (wordN) N width justify indent            If this is the last line, print it and we're done
        PrintLine                                               % [/f] (wordN+1)..[/f] (wordX)                                                          Otherwise, print it and continue

        /first false def                                        % [/f] (wordN+1)..[/f] (wordX)      This isn't the first line

    } loop

    /pageLine pageLine 1 add def                                %                                   Skip a line between paragraphs

} def

/Times-Roman (This) (paragraph) (should) (be) /Times-Roman-Bold (indented,) /Times-Roman (meaning) (the) (first) (line) (is) (spaced) (out) (from) (the) (margin;)
(and) /Times-Roman-Bold (justified,) /Times-Roman (meaning) (the) (ends) (of) (lines) (line) (up) (together) (on) (the) (margin) (--) (quite) (like) (the) (beginnings) (--) (except) (the) (final) (line,) (unless) (it) (just) (happens) (to) (be) (the) (right) (length.)
(There) (should) (also) (be) /Times-Roman-Bold (leading,) /Times-Roman (or) (spacing) (between) (each) (line,) (and) (in) (this) (case) (it) (should) (be) /Times-Roman-Italic (fifteen) (percent) /Times-Roman (of) (the) (font) (height.)

PrintParagraph

/Times-Roman (Here) (is) (another) (paragraph.)
(There) (should) (be) (one) (line's) (worth) (of) (space) (between) (this) (and) (the) (previous) (paragraph.)

PrintParagraph

/Times-Roman (This) (paragraph) (is) (only) (one) (line.)

PrintParagraph

showpage
