%!PS

% Convert Inches to Points
% in --> pt
/in { 72 mul } def

/PageWidth 8.5 in def
/PageHeight 11 in def

/MarginX 1 in def
/MarginY 1 in def
/Indent 0.5 in def
/LineWidth PageWidth MarginX 2 mul sub def

/FontFace /Times def
/FontSize 16 def
/Leading 0.15 def

/pageLine 0 def

% TODO - Indentation (requires changing line generation width limit)
% TODO - Change Font/Formatting for Each Word (use raw names in stack or maybe numbers with a decode function)
% TODO - Paragraph Routine (keep in mind single-line paragraphs)
% TODO - Handle Overflow of Paragraph into Another Page

% TODO - Additional Formatting Things - Lists, Blockquotes, Code Blocks etc.

% TODO (maybe) - Space out Err throughout All Chars (single-word lines)
% TODO (maybe) - Special Things for Dashes and other Word Separators

% TODO - Make a Program to Generate this Document from Plaintext (maybe keep in res but no example, use fancy comments)

% Calculate a Line of Words
% (word1)..(wordX) --> (wordN+1)..(wordX) (word1)..(wordN) N width final
/CalcLine {

    /curLineWidth 0 def                                         % (word1)..(wordX)
    /curLineWords 0 def
    /nxtLineWidth 0 def

    count {

        /final false def                                        % (nxt)..(cur)                  If we exit, this isn't the final line

        count -1 roll                                           % (nxt)..(cur)                  Bring up current word
        FontFace findfont FontSize scalefont setfont            % (nxt)..(cur)                  Set word font

        dup stringwidth pop nxtLineWidth add                    % (nxt)..(cur) width            Width of line including this word
        dup LineWidth gt { pop count 1 roll exit } if           % (nxt)..(cur) width            If word doesn't fit, stop here
        /curLineWidth exch def                                  % (nxt)..(cur)                  Otherwise, add to width
        /curLineWords curLineWords 1 add def                    % (nxt)..(cur)                  Increment word counter

        /nxtLineWidth ( ) stringwidth pop curLineWidth add def  % (nxt)..(cur)                  Width of line including this word with whitespace
        nxtLineWidth LineWidth ge { exit } if                   % (nxt)..(cur)                  If whitespace doesn't fit, stop here

        /final true def                                         % (nxt)..(cur)                  If we exit, this is the final line

    } repeat

    curLineWords curLineWidth final                             % (wordN+1)..(wordX) (word1)..(wordN) N width final

} def

% Print a Line of Words 
% (word1)..(wordN) N width justify --> -
/PrintLine {

                                                                % (word1)..(wordN) N width justify
    MarginX                                                     % (word1)..(wordN) N width justify x
    PageHeight MarginY sub pageLine 1 add                       % (word1)..(wordN) N width justify x top line+1             Top of page and line number
    FontSize Leading 1 add mul                                  % (word1)..(wordN) N width justify x top line+1 spacing     Spacing per line
    mul Leading sub sub                                         % (word1)..(wordN) N width justify x y                      Point of line from the top (ignore line-zero leading)
    moveto                                                      % (word1)..(wordN) N width justify                          Move pointer

    /err 0 def
    {

        LineWidth exch sub                                      % (word1)..(wordN) N bal        Amount of space remaining
        1 index 1 sub div                                       % (word1)..(wordN) N err        Points to add to whitespace
        /err exch def                                           % (word1)..(wordN) N
        
    } { pop } ifelse                                            % (word1)..(wordN) N            Compute err if we should justify, ensure width is discarded

    -1 1 {

                                                                % (cur) (nxt)..(wordN) i        i = words remaining
        dup 1 add -1 roll                                       % (nxt)..(wordN) i (cur)        Bring up current word
        FontFace findfont FontSize scalefont setfont            % (nxt)..(wordN) i (cur)        Set word font
        show                                                    % (nxt)..(wordN) i              Print current word

        1 gt { err 0 ( ) ashow } if                             % (nxt)..(wordN)                If there are more words, print whitespace with extra points

    } for                                                       %                               Loop through all words

    /pageLine pageLine 1 add def                                %                               Next time, next line

} def

(This) (paragraph) (should) (be) (justified,) (meaning) (the) (ends) (of) (lines) (should) (line) (up) (together,) (just) (like) (the) (beginnings,) (except) (the) (final) (line,) (unless) (it) (just) (happens) (to) (be) (the) (right) (length.)

{

    CalcLine                                                    % (wordN+1)..(wordX) (word1)..(wordN) N width final                 Calculate a line
    dup not exch                                                % (wordN+1)..(wordX) (word1)..(wordN) N width justify final         Set up printing parameters and condition
    { PrintLine exit } if                                       % (wordN+1)..(wordX) (word1)..(wordN) N width justify               If this is the last line, print it and we're done
    PrintLine                                                   % (wordN+1)..(wordX)                                                Otherwise, print it and continue

} loop

showpage
