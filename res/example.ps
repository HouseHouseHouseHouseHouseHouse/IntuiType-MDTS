%!PS-Adobe-2.0

% Convert Inches to Points
% in --> pt
/in { 72 mul } def

/PageWidth 8.5 in def
/PageHeight 11 in def

/MarginX 1 in def
/MarginY 1 in def
/Indent 0.5 in def

/FontHeight 16 def
/Leading 0.15 def

/pageLine 0 def

% TODO - Additional Formatting Things - Lists, Blockquotes, Code Blocks etc.
% TODO - Columns, Rules, Page Breaks
% TODO - Higher-Order Indentation (use integer as indent parameter)

% TODO (maybe) - Space out Err throughout All Chars (single-word lines)
% TODO (maybe) - Special Things for Dashes and other Word Separators

% TODO - Make a Program to Generate this Document from Plaintext (maybe keep in res/ but no example, use fancy comments)

% Calculate a Line of Words
% BASE [/f] (word1)..[/f] (wordX) indent --> BASE [/f] (wordN+1)..[/f] (wordX) /f (word1)../f (wordN) N width final
%
% The entire stack should be the remaining words in a paragraph,
% starting at the base, with optional font names below each
% word. Words that will fit in one line will be placed at the
% top and a font name will be specified for each.
/CalcLine {

                                                                % [/f] (word1)..[/f] (wordX) indent
    /curLineWidth 0 def                                         % [/f] (word1)..[/f] (wordX) indent     If a word fits, the total width is here
    /nxtLineWidth 0 def                                         % [/f] (word1)..[/f] (wordX) indent     Used to check if a word will fit with previous whitespace
    /curLineWords 0 def

    /maxLineWidth PageWidth MarginX 2 mul sub                   % [/f] (word1)..[/f] (wordX) indent /v width        Maximum line width
    2 index { Indent sub } if def pop                           % [/f] (word1)..[/f] (wordX)                        Account for indent if necessary

    0                                                           % [/f] (word1)..[/f] (wordX) 0      Mark the end of the paragraph

    /curFontFace /Times-Roman def

    {

        % This part checks what's next, it may not be a word
        /final true def                                         % [/f] (cur)../f (pre)              If we exit, this is the final line

        count -1 roll                                           % ../f (pre) [(cur) OR /f OR 0]     Bring up current word, next font name, or end mark

        dup 0 eq { count 1 roll exit } if                       % ../f (pre) [(cur) OR /f]          If this is the end mark, replace it and exit

        dup type /nametype eq {
                                                                % (cur) [/f] (nxt)../f (pre) /f
            /curFontFace exch def                               % (cur) [/f] (nxt)../f (pre)        If this is a font name, set variable
            count -1 roll                                       % [/f] (nxt)../f (pre) (cur)        Bring up current word
        } if
        curFontFace exch                                        % [/f] (nxt)../f (pre) /f (cur)     Bury current font for print routine

        % This part checks if the word will fit in the line
        /final false def                                        % [/f] (nxt)../f (cur)              If we exit, this isn't the final line

        curFontFace findfont FontHeight scalefont setfont       % [/f] (nxt)../f (cur)              Set word font
        dup stringwidth pop nxtLineWidth add                    % [/f] (nxt)../f (cur) width        Width of line including this word
        dup maxLineWidth gt { pop count 2 roll exit } if        % [/f] (nxt)../f (cur) width        If word doesn't fit, stop here
        /curLineWidth exch def                                  % [/f] (nxt)../f (cur)              Otherwise, add to width
        /curLineWords curLineWords 1 add def                    % [/f] (nxt)../f (cur)              Increment word counter

        % This part checks if whitespace will fit in the line
        /nxtLineWidth ( ) stringwidth pop curLineWidth add def  % [/f] (nxt)../f (cur)              Width of line including this word with whitespace
        nxtLineWidth maxLineWidth ge { exit } if                % [/f] (nxt)../f (cur)              If whitespace doesn't fit, stop here

    } loop

                                                                % [/f] (wordN+1)..[/f] (wordX) 0 /f (word1)../f (wordN)
    curLineWords 2 mul 1 add -1 roll pop                        % [/f] (wordN+1)..[/f] (wordX) /f (word1)../f (wordN)
    curLineWords curLineWidth final                             % [/f] (wordN+1)..[/f] (wordX) /f (word1)../f (wordN) N width final

} def

% Print a Line of Words 
% /f (word1)../f (wordN) N width justify indent --> -
%
% The stack should contain a font name for every word in the line.
% All words will be printed onto the current line, and the line will
% be advanced.
/PrintLine {

    % This part places the pointer                              % /f (word1)../f (wordN) N width justify indent
    exch 1 index                                                % /f (word1)../f (wordN) N width indent justify indent
    MarginX exch { Indent add } if                              % /f (word1)../f (wordN) N width indent justify x                       Start at left margin and indent if necessary
    0                                                           % /f (word1)../f (wordN) N width indent justify x 0                     Placeholder Y-value

    2 {

        pop                                                     % /f (word1)../f (wordN) N width indent justify x                       Discard placeholder/incorrect Y-value
        PageHeight MarginY sub pageLine                         % /f (word1)../f (wordN) N width indent justify x top line              Top margin and line number
        FontHeight Leading 1 add mul                            % /f (word1)../f (wordN) N width indent justify x top line spacing      Spacing per line
        mul FontHeight add sub                                  % /f (word1)../f (wordN) N width indent justify x y                     Y-value of line (pointer is bottom of line)

        dup MarginY lt { showpage /pageLine 0 def } if          % /f (word1)../f (wordN) N width indent justify x y                     If we're below the bottom margin, new page and reset line

    } repeat                                                    % /f (word1)../f (wordN) N width indent justify x y                     Calculate two times in case the line had to be changed
    moveto                                                      % /f (word1)../f (wordN) N width indent justify                         Move pointer

    % This part calculates the err for justifying
    /err 0 def
    {

        PageWidth MarginX 2 mul sub                             % /f (word1)../f (wordN) N width indent maxWidth      Maximum width
        exch { Indent sub } if                                  % /f (word1)../f (wordN) N width maxWidth             Account for indent if necessary
        exch sub                                                % /f (word1)../f (wordN) N balance                    Amount of space remaining
        1 index 1 sub div                                       % /f (word1)../f (wordN) N err                        Points to add to whitespace
        /err exch def                                           % /f (word1)../f (wordN) N

    } { pop pop } ifelse                                        % /f (word1)../f (wordN) N          Compute err if we should justify, ensure width and indent are discarded

    % This part prints each word
    -1 1 {

                                                                % /f (cur)../f (wordN) i                i = words remaining
        dup 2 mul 1 add -2 roll                                 % /f (nxt)../f (wordN) i /f (cur)       Bring up current word or next font name
        exch findfont FontHeight scalefont setfont              % /f (nxt)../f (wordN) i (cur)          Set word font
        show                                                    % /f (nxt)../f (wordN) i                Print current word

        1 gt { err 0 ( ) ashow } if                             % /f (nxt)../f (wordN)                  If there are more words, print whitespace with extra points

    } for                                                       %                                   Loop through all words

    /pageLine pageLine 1 add def                                %                                   Next time, next line

} def

% Print a Paragraph
% BASE /f (word1) [/f] (word2)..[/f] (wordX) -> BASE -
%
% The stack should consist of only the words in the paragraph.
% Words are individual strings optionally preceded by a font
% name. The first word is at the base of the stack and it must
% have a font name.
/PrintParagraph {

    /first true def                                             % /f (word1)..[/f] (wordX)          This is the first line
    {

        first CalcLine                                          % [/f] (wordN+1)..[/f] (wordX) /f (word1)../f (wordN) N width final                     Calculate a line
        dup not exch first exch                                 % [/f] (wordN+1)..[/f] (wordX) /f (word1)../f (wordN) N width justify indent final      Set up printing parameters and condition
        { PrintLine exit } if                                   % [/f] (wordN+1)..[/f] (wordX) /f (word1)../f (wordN) N width justify indent            If this is the last line, print it and we're done
        PrintLine                                               % [/f] (wordN+1)..[/f] (wordX)                                                          Otherwise, print it and continue

        /first false def                                        % [/f] (wordN+1)..[/f] (wordX)      This isn't the first line

    } loop

    /pageLine pageLine 1 add def                                %                                   Skip a line between paragraphs

} def

/Times-Roman (This) (paragraph) (should) (be) /Times-Roman-Bold (indented,) /Times-Roman (meaning) (the) (first) (line) (is) (spaced) (out) (from) (the) (margin;)
(and) /Times-Roman-Bold (justified,) /Times-Roman (meaning) (the) (ends) (of) (lines) (line) (up) (together) (on) (the) (margin) (--) (quite) (like) (the) (beginnings) (--) (except) (the) (final) (line,) (unless) (it) (just) (happens) (to) (be) (the) (right) (length.)
(There) (should) (also) (be) /Times-Roman-Bold (leading,) /Times-Roman (or) (spacing) (between) (each) (line,) (and) (in) (this) (case) (it) (should) (be) /Times-Roman-Italic (fifteen) (percent) /Times-Roman (of) (the) (font) (height.)

PrintParagraph

/Times-Roman (Here) (is) (another) (paragraph.)
(There) (should) (be) (one) (line's) (worth) (of) (space) (between) (this) (and) (the) (previous) (paragraph.)

PrintParagraph

/Times-Roman (This) (paragraph) (is) (only) (one) (line.)

PrintParagraph
PrintParagraph
PrintParagraph
PrintParagraph
PrintParagraph
PrintParagraph
PrintParagraph
PrintParagraph
PrintParagraph
PrintParagraph
PrintParagraph

/Times-Roman (This) (paragraph) (is) (too) (long) (to) (be) (kept) (on) (the) (first) (page,) (so) (a) (second) (one) (is) (made) (for) (it.)
(If) (you're) (viewing) (this) (in) (a) (document) (reader) (or) (previewer,) (Evince) (for) (instance,)
(you) (may) (notice) (that) (there) (is) (only) (one) (page,) (and) (that) (this) (paragraph) (starts) (rather) (abruptly,) (without) (indentation.)
(This) (is) (because) (those) (programs) (are) (expecting) (special) (comments) (with) (the) (page) (count) (and) (numbering.)
(Programs) (like) (GhostScript,) (however,) (render) (this) (document) (perfectly) (fine.)
(Also,) (utilities) (like) (PS2PDF) (will) (convert) (this) (document) (to) (PDF,) (and) (document) (readers) (will) (render) (it) (well.)

PrintParagraph

showpage
