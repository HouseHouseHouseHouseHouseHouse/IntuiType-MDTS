%!PS-Adobe-2.0

% Convert Inches to Points
% in --> pt
/in { 72 mul } def
/mm { 2.83465 mul } def

% Set Page Dimensions from Paper Size
/PaperSize /letter def

PaperSize /letter eq {
    /PageWidth 8.5 in def
    /PageHeight 11 in def
} if

PaperSize /a4 eq {
    /PageWidth 210 mm def
    /PageHeight 297 mm def
} if

<< /PageSize [ PageWidth PageHeight ] >> setpagedevice

% Document Standards
/MarginX 1 in def
/MarginY 1 in def
/Indent 0.5 in def
/Gutter 0.5 in def

/DefaultFontFace /Times-Roman def

% Section Parameters
/FontHeight 12 def
/Leading 0.15 def

/ColumnPortions [ 1 1 ] def

% Header Parameters
/HeaderLeft { 0 0 } def
/HeaderCentre { 0 0 } def
/HeaderRight { 0 0 } def

/HeaderFontHeight 12 def
/HeaderLeading 0.15 def

% Footer Parameters
/FooterLeft { 0 0 } def
/FooterCentre { 0 0 } def
/FooterRight { 0 0 } def

/FooterFontHeight 12 def
/FooterLeading 0.15 def

% Variables
/PaddingX 0 in def

/documentPage 1 def
/pageColumn 0 def
/pageLine 0 def

% TODO - Auto-Break a Word that's Too Long
% TODO - Headers
% TODO - Sections, Global Parameters (Font Size, Leading, Columns) can be Changed (calculate position by adding an offset to Y which is reset on new page)

% TODO (maybe) - Font Colour

% TODO - Make a Program to Generate this Document from Plaintext (maybe keep in res/ but no example, use fancy comments)

% Get Position and Width of Current Line
% - --> width x y
/Line {

    % This part finds the width and X-value of the line
    PageWidth MarginX 2 mul sub                                     % available                     Total space between margins
    MarginX                                                         % available x                   X-value of left margin

    pageLine type /nametype ne                                      % available x contentMode       If we're dealing with content, deal with columns and padding
    {

        % This part finds the width of each portion of column distribution
        pop                                                         % available                     This isn't the X-value we need
        ColumnPortions length 1 sub Gutter mul sub                  % available                     Account for gutters
        ColumnPortions aload pop                                    % available ptn..               All portion values
        ColumnPortions length 1 sub { add } repeat                  % available ptns                Sum them up
        div                                                         % ptnWidth                      Width of each portion

        % This part finds the width of the line
        ColumnPortions pageColumn get                               % ptnWidth curPtns              Portions in current column
        1 index mul                                                 % ptnWidth width                Width of current column
        PaddingX 2 mul sub                                          % ptnWidth width                Account for padding

        % This part finds the X-value of the start of the line
        0 0 1 pageColumn 1 sub { ColumnPortions exch get add } for  % ptnWidth width lPtns          Total portions in columns to the left
        2 index mul pageColumn Gutter mul add MarginX add           % ptnWidth width x              X-value of column (add columns and gutters to the left)
        PaddingX add                                                % ptnWidth width x              Account for padding

        3 -1 roll pop                                               % width x

    } if

    % This part finds the Y-value of the line
    pageLine type /nametype ne                                      % width x special               Is this a special line?
    {
        PageHeight MarginY sub pageLine                             % width x top line              If not, top margin and line number
        FontHeight Leading 1 add mul                                % width x top line spacing      Spacing per line
        mul FontHeight add sub                                      % width x y                     Pointer is at bottom of line
    } {
        pageLine /header eq                                         % width x header                Is this the header?
        {
            PageHeight MarginY sub                                  % width x top                   If so, top margin
            HeaderFontHeight HeaderLeading 1 add mul add            % width x y                     Go up one line
        } {
            MarginY                                                 % width x bottom                Otherwise, bottom margin
            FooterFontHeight FooterLeading 1 add mul sub            % width x y                     Go down one line
        } ifelse
    } ifelse                                                        % width x y

} def

% Advance to Next Line/Column/Page
/NextLine {

    /pageLine pageLine 1 add def                                    %                               Next line

    Line MarginY lt                                                 % width x overflow              Is this line in the bottom margin?
    { NextColumn } if                                               % width x                       If so, next column

    pop pop                                                         %

} def

% Advance to Next Column/Page
/NextColumn {

    /pageLine 0 def                                                 %                               Reset line
    /pageColumn pageColumn 1 add def                                %                               Next column

    pageColumn ColumnPortions length eq                             % pageFull                      Are we out of columns?
    { NextPage } if                                                 %                               If so, next page

} def

% Advance to Next Page
/NextPage {

    showpage                                                        %                               Finish off that page and start a new one
    NewPage                                                         %                               Set up new page
    /documentPage documentPage 1 add def                            %                               Increment page number

} def

% Set Up New Page
/NewPage {

    /pageLine /header def                                           %                               Header line
    HeaderLeft false 0 0 PrintLine                                  %                               Print left-aligned part of header
    HeaderCentre false 1 0 PrintLine                                %                               Print centre-aligned part of header
    HeaderRight false 2 0 PrintLine                                 %                               Print right-aligned part of header

    /pageLine /footer def                                           %                               Footer line
    FooterLeft false 0 0 PrintLine                                  %                               Print left-aligned part of footer
    FooterCentre false 1 0 PrintLine                                %                               Print centre-aligned part of footer
    FooterRight false 2 0 PrintLine                                 %                               Print right-aligned part of footer

    /pageLine 0 def                                                 %                               Reset line
    /pageColumn 0 def                                               %                               Reset column

} def

% Calculate a Line of Words
% /f (word1) [/f] (word2)..[/f] (wordX) maxItems indent --> /f (wordN+1) [/f] (wordN+2)..[/f] (wordX) /f (word1)../f (wordN) N width final
%
% The stack should contain the remaining words in a paragraph,
% starting from the base, with optional font names below each
% word. This procedure will only manipulate the number of things
% specified in the stack. Words that will fit in one line will
% be placed at the top and a font name will be placed before
% each.
/CalcLine {

                                                                % /f (word1) [/f] (word2)..[/f] (wordX) maxItems indent
    /curLineWidth 0 def                                         % /f (word1) [/f] (word2)..[/f] (wordX) maxItems indent     If a word fits, the total width is here
    /nxtLineWidth 0 def                                         % /f (word1) [/f] (word2)..[/f] (wordX) maxItems indent     Used to check if a word will fit with previous whitespace
    /curLineWords 0 def

    /maxLineWidth Line pop pop                                  % /f (word1) [/f] (word2)..[/f] (wordX) maxItems indent /v width        Maximum line width
    2 index Indent mul sub def pop                              % /f (word1) [/f] (word2)..[/f] (wordX) maxItems                        Account for indentation if necessary

    /maxItems exch 1 add def                                    % /f (word1) [/f] (word2)..[/f] (wordX)         Stack item count

    0                                                           % /f (word1) [/f] (word2)..[/f] (wordX) 0       Mark the end of the paragraph

    {

        % This part checks what's next, it may not be a word
        /final true def                                         % [/f] (cur)../f (pre)              If we exit, this is the final line

        maxItems -1 roll                                        % ../f (pre) [(cur) OR /f OR 0]     Bring up current word, next font name, or end mark

        dup 0 eq { maxItems 1 roll exit } if                    % ../f (pre) [(cur) OR /f]          If this is the end mark, replace it and exit

        dup type /nametype eq
        {                                                       % (cur) [/f] (nxt)../f (pre) /f
            /curFontFace exch def                               % (cur) [/f] (nxt)../f (pre)        If this is a font name, set variable
            /maxItems maxItems 1 sub def                        % [/f] (nxt)../f (pre) (cur)        Account for lost item
            maxItems -1 roll                                    % [/f] (nxt)../f (pre) (cur)        Bring up current word
        } if

        curFontFace exch                                        % [/f] (nxt)../f (pre) /f (cur)     Bury current font for print routine
        /maxItems maxItems 1 add def                            % [/f] (nxt)../f (pre) /f (cur)     Account for additional item

        % This part checks if the word will fit in the line
        /final false def                                        % [/f] (nxt)../f (cur)              If we exit, this isn't the final line

        curFontFace findfont FontHeight scalefont setfont       % [/f] (nxt)../f (cur)              Set word font
        dup stringwidth pop nxtLineWidth add                    % [/f] (nxt)../f (cur) width        Width of line including this word
        dup maxLineWidth gt { pop maxItems 2 roll exit } if     % [/f] (nxt)../f (cur) width        If word doesn't fit, stop here
        /curLineWidth exch def                                  % [/f] (nxt)../f (cur)              Otherwise, add to width
        /curLineWords curLineWords 1 add def                    % [/f] (nxt)../f (cur)              Increment word counter

        % This part adds whitespace in case the next word also fits
        /nxtLineWidth ( ) stringwidth pop curLineWidth add def  % [/f] (nxt)../f (cur)              Width of line including this word with whitespace

    } loop

                                                                % /f (wordN+1) [/f] (wordN+2)..[/f] (wordX) 0 /f (word1)../f (wordN)
    curLineWords 2 mul 1 add -1 roll pop                        % /f (wordN+1) [/f] (wordN+2)..[/f] (wordX) /f (word1)../f (wordN)
    curLineWords curLineWidth final                             % /f (wordN+1) [/f] (wordN+2)..[/f] (wordX) /f (word1)../f (wordN) N width final

} def

% Print a Line of Words 
% /f (word1)../f (wordN) N width justify align indent --> -
%
% The stack should contain a font name for every word in the line.
% All words will be printed onto the current line.
/PrintLine {

    % This part calculates the remaining space in the line      % /f (word1)../f (wordN) N width justify align indent
    4 -1 roll                                                   % /f (word1)../f (wordN) N justify align indent width
    Line pop pop                                                % /f (word1)../f (wordN) N justify align indent width maxWidth      Maximum line width
    2 index Indent mul sub                                      % /f (word1)../f (wordN) N justify align indent width maxWidth      Account for indentation if necessary
    exch sub                                                    % /f (word1)../f (wordN) N justify align indent balance             Amount of space remaining
    4 -2 roll exch                                              % /f (word1)../f (wordN) N indent balance align justify

    % This part calculates the err for justifying
    /err 0 def
    /charErr 0 def
    {
                                                                % /f (word1)../f (wordN) N indent balance align
        pop 2 index                                             % /f (word1)../f (wordN) N indent balance N
        dup 1 ne                                                % /f (word1)../f (wordN) N indent balance N plural      Is there more than one word in this line?
        {
            1 sub div                                           % /f (word1)../f (wordN) N indent err                   If so, calculate points to add to whitespace
            /err exch def                                       % /f (word1)../f (wordN) N indent
        } {
            pop 4 index length                                  % /f (word1)../f (wordN) N indent chars                 Otherwise, number of chars in word
            1 sub div                                           % /f (word1)../f (wordN) N indent charErr               Calculate points to add to each char
            /charErr exch def                                   % /f (word1)../f (wordN) N indent
        } ifelse

        Line 3 -1 roll pop                                      % /f (word1)../f (wordN) N indent x y                   Use default X-value to start at left margin

    }

    % This part calculates the offset for aligning
    {

                                                                % /f (word1)../f (wordN) N indent balance align
        2 div mul                                               % /f (word1)../f (wordN) N indent offset                Offset to align to the right side
        Line exch 4 -2 roll pop                                 % /f (word1)../f (wordN) N indent y x offset            Default X-value
        add exch                                                % /f (word1)../f (wordN) N indent x y                   Add offset to align properly

    } ifelse                                                    % /f (word1)../f (wordN) N indent x y

    % This part positions the pointer
    3 1 roll exch Indent mul add exch                           % /f (word1)../f (wordN) N x y                          Account for indentation if necessary
    moveto                                                      % /f (word1)../f (wordN) N                              Move pointer

    % This part prints each word
    -1 1 {

                                                                % /f (cur)../f (wordN) i                i = words remaining
        dup 2 mul 1 add -2 roll                                 % /f (nxt)../f (wordN) i /f (cur)       Bring up current word or next font name
        exch findfont FontHeight scalefont setfont              % /f (nxt)../f (wordN) i (cur)          Set word font
        charErr exch 0 exch ashow                               % /f (nxt)../f (wordN) i                Print current word with any char err

        1 gt { err 0 ( ) ashow } if                             % /f (nxt)../f (wordN)                  If there are more words, print whitespace with extra points

    } for                                                       %                                   Loop through all words

} def

% Print a Paragraph
% BASE /f (word1) [/f] (word2)..[/f] (wordX) -> BASE -
%
% The stack should consist of only the words in the paragraph.
% Words are individual strings optionally preceded by a font
% name. The first word is at the base of the stack and it must
% have a font name.
/PrintParagraph {

    /PaddingX 0 in def                                          % /f (word1)..[/f] (wordX)          No padding

    /indent 1 def                                               % /f (word1)..[/f] (wordX)          This is the first line, so indent once
    {

        count indent CalcLine                                   % /f (wordN+1) [/f] (wordN+2)..[/f] (wordX) /f (word1)../f (wordN) N width final                            Calculate a line
        dup not 0 indent 4 -1 roll                              % /f (wordN+1) [/f] (wordN+2)..[/f] (wordX) /f (word1)../f (wordN) N width justify align indent final       Set up printing parameters and condition
        { PrintLine exit } { PrintLine } ifelse                 % /f (wordN+1) [/f] (wordN+2)..[/f] (wordX)                                                                 Print line, exit if we're done
        NextLine                                                % /f (wordN+1) [/f] (wordN+2)..[/f] (wordX)                                                                 Next line/column/page

        /indent 0 def                                           % /f (wordN+1) [/f] (wordN+2)..[/f] (wordX)     This isn't the first line, so don't indent

    } loop

    NextLine                                                    %                                   We didn't advance a line last time
    NextLine                                                    %                                   Skip a line between paragraphs

} def

% Print a Paragraph with Alignment
% BASE /f (word1) [/f] (word2)..[/f] (wordX) indent1 align -> BASE -
%
% Alignment is specified using an integer. 0 means left-align, 1
% means centre-align, and 2 means right-align. Whether the first
% line should be indented is specified using a boolean.
/PrintParagraphAligned {

    /PaddingX 0 in def                                          % /f (word1)..[/f] (wordX) indent1 align        No padding
    /align exch def                                             % /f (word1)..[/f] (wordX) indent1              Set variable

    /indent exch { 1 } { 0 } ifelse def                         % /f (word1)..[/f] (wordX)          Indent the first line once if necessary
    {

        count indent CalcLine                                   % /f (wordN+1) [/f] (wordN+2)..[/f] (wordX) /f (word1)../f (wordN) N width final                            Calculate a line
        false align indent 4 -1 roll                            % /f (wordN+1) [/f] (wordN+2)..[/f] (wordX) /f (word1)../f (wordN) N width justify align indent final       Set up printing parameters and condition
        { PrintLine exit } { PrintLine } ifelse                 % /f (wordN+1) [/f] (wordN+2)..[/f] (wordX)                                                                 Print line, exit if we're done
        NextLine                                                % /f (wordN+1) [/f] (wordN+2)..[/f] (wordX)                                                                 Next line/column/page

        /indent 0 def                                           % /f (wordN+1) [/f] (wordN+2)..[/f] (wordX)     Don't indent subsequent lines

    } loop

    NextLine                                                    %                                   We didn't advance a line last time
    NextLine                                                    %                                   Skip a line between paragraphs

} def


% Print a Block-Quote
% BASE /f (word1) [/f] (word2)..[/f] (wordX) -> BASE -
/PrintBlockQuote {

    /PaddingX Indent def                                        % /f (word1) [/f] (word2)..[/f] (wordX)     Pad by the indentation amount

    {

        count 0 CalcLine                                        % /f (wordN+1) [/f] (wordN+2)..[/f] (wordX) /f (word1)../f (wordN) N width final                            Calculate a line
        dup not 0 0 4 -1 roll                                   % /f (wordN+1) [/f] (wordN+2)..[/f] (wordX) /f (word1)../f (wordN) N width justify align indent final       Set up printing parameters and condition
        { PrintLine exit } { PrintLine } ifelse                 % /f (wordN+1) [/f] (wordN+2)..[/f] (wordX)                                                                 Print line, exit if we're done
        NextLine                                                % /f (wordN+1) [/f] (wordN+2)..[/f] (wordX)                                                                 Next line/column/page

    } loop

    NextLine                                                    %                                   We didn't advance a line last time
    NextLine                                                    %                                   Skip a line

} def

% Print a List Item
% BASE /f (word1) [/f] (word2)..[/f] (wordX) (index) order -> BASE -
/PrintListItem {

    /PaddingX 0 in def                                          % /f (word1) [/f] (word2)..[/f] (wordX) (index) order       No padding
    /indent exch def                                            % /f (word1) [/f] (word2)..[/f] (wordX) (index)             Times to indent for index

    Line exch indent Indent mul add exch                        % /f (word1) [/f] (word2)..[/f] (wordX) (index) width x y       Current line with necessary indentation
    moveto pop                                                  % /f (word1) [/f] (word2)..[/f] (wordX) (index)                 Move pointer

    DefaultFontFace findfont FontHeight scalefont setfont       % /f (word1) [/f] (word2)..[/f] (wordX) (index)             Set default font
    show (.) show                                               % /f (word1) [/f] (word2)..[/f] (wordX)                     Print index

    /indent indent 1 add def                                    % /f (word1) [/f] (word2)..[/f] (wordX)                     Indent once more past the index

    {

        count indent CalcLine                                   % /f (wordN+1) [/f] (wordN+2)..[/f] (wordX) /f (word1)../f (wordN) N width final                            Calculate a line
        dup not 0 indent 4 -1 roll                              % /f (wordN+1) [/f] (wordN+2)..[/f] (wordX) /f (word1)../f (wordN) N width justify align indent final       Set up printing parameters and condition
        { PrintLine exit } { PrintLine } ifelse                 % /f (wordN+1) [/f] (wordN+2)..[/f] (wordX)                                                                 Print line, exit if we're done
        NextLine                                                % /f (wordN+1) [/f] (wordN+2)..[/f] (wordX)                                                                 Next line/column/page

    } loop

    NextLine                                                    %                                   We didn't advance a line last time
    NextLine                                                    %                                   Skip a line

} def

% Print a Rule
/PrintRule {

    /PaddingX Indent 2 div def                                  %                                   Pad by half the indentation amount

    newpath                                                     %                                   New path

    Line moveto                                                 % width                             Move pointer to current line
    0 FontHeight 2 div rmoveto                                  % width                             Centre of line
    0 rlineto                                                   %                                   Symmetric rule

    gsave                                                       %                                   Save Graphics Context

    0.5 setgray 2 setlinewidth 2 setlinecap                     %                                   Grey, 2 pt line, square cap
    stroke                                                      %                                   Draw

    grestore                                                    %                                   Restore Graphics Context

    NextLine                                                    %                                   Don't use this line

} def

NewPage

/Times-Roman (The) (first) (line) (of) (this) (paragraph) (should) (be) /Times-Bold (indented,) /Times-Roman (meaning) (there) (is) (space) (between) (the) (left) (margin) (and) (the) (type,)
(which) (in) (this) (case) (it) (should) (be) /Times-Italic (one) (inch) /Times-Roman (of) (space.)
(This) (paragraph) (should) (be) /Times-Bold (justified,) /Times-Roman (meaning) (the) (left) (side) (of) (the) (is) (flush) (with) (the) (left) (margin,) (and) (the) (right) (side) (is) (flush) (with) (the) (right) (margin,)
(except) (the) (final) (line,) (unless) (it) (just) (happens) (to) (be) (the) (right) (length.)
(There) (should) (also) (be) /Times-Bold (leading,) /Times-Roman (or) (space) (between) (each) (line,) (and) (in) (this) (case) (it) (should) (be) /Times-Italic (fifteen) (percent) /Times-Roman (of) (the) (font) (height.)

PrintParagraph

/Times-Roman (Here) (is) (another) (paragraph.)
(There) (should) (be) (one) (line's) (worth) (of) (space) (between) (this) (and) (the) (previous) (paragraph.)
(Paragraph) (spacing) (is) (used) (in) (addition) (to) (indentation) (to) (emphasize) (the) (change) (in) (subject) (matter) (between) (paragraphs.)

PrintParagraph

PrintRule

/Times-Roman (This) (paragraph) (should) (be) /Times-Bold (left-aligned,) /Times-Roman (meaning) (the) (left) (side) (of) (the) (paragraph) (is) (flush) (with) (the) (left) (margin,) (and) (nothing) (else.)
(This) (means) (that) (the) (right) (side) (of) (the) (paragraph) (is) (uneven,) (or) /Times-Bold (ragged.) /Times-Roman
(This) (is) (how) (one) (typically) (writes) (a) (paragraph,) (and) (how) (most) (style) (guides) (suggest) (a) (paragraph) (be) (typeset.)

true 0 PrintParagraphAligned

/Times-Roman (This) (paragraph) (should) (be) /Times-Bold (right-aligned.) /Times-Roman
(The) (right) (side) (of) (the) (paragraph) (is) (flush) (with) (the) (right) (margin,) (and) (the) (left) (side) (is) (ragged.)
(Because) (of) (the) (latter) (detail,) (and) (since) (it) (wouldn't) (be) (consistent,) (the) (first) (line) (of) (this) (paragraph) (is) (not) (indented.)
(Paragraphs) (typically) (are) (not) (aligned) (this) (way) (as) (it) (makes) (it) (harder) (to) (start) (reading) (the) (next) (line.)

false 2 PrintParagraphAligned

/Times-Roman (This) (paragraph) (should) (be) /Times-Bold (centre-aligned,) /Times-Roman (meaning) (each) (line) (is) (horizontally) (centred) (on) (the) (page.)
(Both) (sides) (of) (the) (paragraph) (are) (ragged.)
(This) (is) (used) (sometimes) (for) (headings) (and) (titles,) (and) (not) (for) (paragraphs.)

false 1 PrintParagraphAligned

PrintRule

/Times-Roman (This) (paragraph) (should) (overflow) (into) (the) (right-hand) (column.)
(Separating) (the) (columns) (should) (be) (a) /Times-Bold (gutter,) /Times-Roman (which) (is) (a) (bit) (of) (horizontal) (spacing,)
(and) (in) (this) (case) (it) (should) (be) /Times-Italic (half) (an) (inch) /Times-Roman (wide.)
(Sometimes) (you) (will) (see) (lines) (separating) (columns) (instead,) (and) (those) (are) (called) /Times-Bold (rules.) /Times-Roman
(In) (fact,) (a) (horizontal) (rule) (should) (be) (between) (this) (paragraph) (and) (the) (previous) (one.)

PrintParagraph

PrintRule

/Times-Roman (This) (is) (the) (first) (item) (in) (a) (list.)
(It) (should) (be) (preceded) (by) (the) (number) (one,) (and) (every) (line) (should) (be) (indented.)

(1) 0 PrintListItem

/Times-Roman (This) (is) (the) (second) (item) (in) (a) (list.)
(Lists) (like) (these) (are) (generally) (used) (in) (memorandums) (for) (brevity) (and) (ease) (in) (reading.)

(2) 0 PrintListItem

/Times-Roman (This) (is) (an) (item) (in) (a) (lower-order) (list.)

(a) 1 PrintListItem

/Times-Roman (Sublist) (items) (are) (generally) (preceded) (by) (lowercase) (letters.)

(b) 1 PrintListItem

/Times-Roman (They) (should) (also) (be) (indented) (further) (than) (higher-order) (items.)

(c) 1 PrintListItem

/Times-Roman (This) (is) (the) (third) (item) (in) (a) (list.)
(Three) (is) (generally) (the) (minimum) (number) (of) (items) (in) (a) (list,) (as) (having) (fewer) (items) (will) (make) (the) (writing) (simple) (enough) (to) (be) (understood) (without) (the) (context) (of) (one.)

(3) 0 PrintListItem

/Times-Roman (This) (is) (a) /Times-Bold (block-quote.) /Times-Roman
(The) (paragraph) (should) (be) (justified,) (and) (every) (line) (should) (be) (indented) (from) (both) (the) (left) (and) (the) (right,) (making) (the) (paragraph) (horizontally) (condensed.)
(Block-quotes) (are) (generally) (used) (when) (a) (quote) (or) (excerpt) (is) (four) (lines) (or) (more.)

PrintBlockQuote

PrintRule

/Times-Roman (This) (paragraph) (is) (too) (long) (to) (be) (kept) (on) (this) (page,) (so) (it) (should) (overflow) (into) (another) (one.)
(If) (you're) (viewing) (this) (in) (a) (document) (reader) (or) (previewer,) (Evince) (for) (instance,)
(you) (may) (notice) (that) (there) (is) (only) (one) (page,) (and) (that) (this) (paragraph) (starts) (rather) (abruptly,) (without) (indentation.)
(This) (is) (because) (those) (programs) (are) (expecting) (special) (comments) (with) (the) (page) (count) (and) (numbering.)
(Programs) (like) (GhostScript,) (however,) (render) (this) (document) (perfectly) (fine.)
(Also,) (utilities) (like) (PS2PDF) (will) (convert) (this) (document) (to) (PDF,) (and) (document) (readers) (will) (render) (it) (well.)

PrintParagraph

showpage
