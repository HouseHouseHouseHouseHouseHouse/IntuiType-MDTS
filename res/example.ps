%!PS

% Convert Inches to Points
% in --> pt
/in { 72 mul } def

/PageWidth 8.5 in def
/PageHeight 11 in def

/MarginX 1 in def
/MarginY 1 in def
/Indent 0.5 in def
/LineWidth PageWidth MarginX 2 mul sub def

/FontFace /Times-Roman def
/FontHeight 16 def
/Leading 0.15 def

/pageLine 0 def

% TODO - Change Font/Formatting for Each Word (use raw names in stack or maybe numbers with a decode function)
% TODO - Paragraph Routine (keep in mind single-line paragraphs)
% TODO - Handle Overflow of Paragraph into Another Page

% TODO - Additional Formatting Things - Lists, Blockquotes, Code Blocks etc.

% TODO (maybe) - Space out Err throughout All Chars (single-word lines)
% TODO (maybe) - Special Things for Dashes and other Word Separators

% TODO - Make a Program to Generate this Document from Plaintext (maybe keep in res but no example, use fancy comments)

% Calculate a Line of Words
% (word1)..(wordX) indent --> (wordN+1)..(wordX) (word1)..(wordN) N width final
/CalcLine {

    /curLineWidth 0 def                                         % (word1)..(wordX) indent
    /curLineWords 0 def
    /nxtLineWidth 0 def

    /maxLineWidth PageWidth MarginX 2 mul sub                   % (word1)..(wordX) indent /v width      Maximum line width
    2 index { Indent sub } if def pop                           % (word1)..(wordX)                      Account for indent if necessary

    count {

        /final false def                                        % (nxt)..(cur)                  If we exit, this isn't the final line

        count -1 roll                                           % (nxt)..(cur)                  Bring up current word
        FontFace findfont FontHeight scalefont setfont          % (nxt)..(cur)                  Set word font

        dup stringwidth pop nxtLineWidth add                    % (nxt)..(cur) width            Width of line including this word
        dup maxLineWidth gt { pop count 1 roll exit } if        % (nxt)..(cur) width            If word doesn't fit, stop here
        /curLineWidth exch def                                  % (nxt)..(cur)                  Otherwise, add to width
        /curLineWords curLineWords 1 add def                    % (nxt)..(cur)                  Increment word counter

        /nxtLineWidth ( ) stringwidth pop curLineWidth add def  % (nxt)..(cur)                  Width of line including this word with whitespace
        nxtLineWidth maxLineWidth ge { exit } if                % (nxt)..(cur)                  If whitespace doesn't fit, stop here

        /final true def                                         % (nxt)..(cur)                  If we exit, this is the final line

    } repeat

    curLineWords curLineWidth final                             % (wordN+1)..(wordX) (word1)..(wordN) N width final

} def

% Print a Line of Words 
% (word1)..(wordN) N width justify indent --> -
/PrintLine {

                                                                % (word1)..(wordN) N width justify indent
    exch 1 index                                                % (word1)..(wordN) N width indent justify indent
    MarginX exch { Indent add } if                              % (word1)..(wordN) N width indent justify x                         Start at left margin and indent if necessary
    PageHeight MarginY sub pageLine                             % (word1)..(wordN) N width indent justify x top line                Top margin and line number
    FontHeight Leading 1 add mul                                % (word1)..(wordN) N width indent justify x top line spacing        Spacing per line
    mul FontHeight add sub                                      % (word1)..(wordN) N width indent justify x y                       Point of line from the top (pointer is bottom of line)
    moveto                                                      % (word1)..(wordN) N width indent justify                           Move pointer

    /err 0 def
    {

        PageWidth MarginX 2 mul sub                             % (word1)..(wordN) N width indent maxWidth      Maximum width
        exch { Indent sub } if                                  % (word1)..(wordN) N width maxWidth             Account for indent if necessary
        exch sub                                                % (word1)..(wordN) N balance                    Amount of space remaining
        1 index 1 sub div                                       % (word1)..(wordN) N err                        Points to add to whitespace
        /err exch def                                           % (word1)..(wordN) N
        
    } { pop pop } ifelse                                        % (word1)..(wordN) N            Compute err if we should justify, ensure width and indent are discarded

    -1 1 {

                                                                % (cur) (nxt)..(wordN) i        i = words remaining
        dup 1 add -1 roll                                       % (nxt)..(wordN) i (cur)        Bring up current word
        FontFace findfont FontHeight scalefont setfont          % (nxt)..(wordN) i (cur)        Set word font
        show                                                    % (nxt)..(wordN) i              Print current word

        1 gt { err 0 ( ) ashow } if                             % (nxt)..(wordN)                If there are more words, print whitespace with extra points

    } for                                                       %                               Loop through all words

    /pageLine pageLine 1 add def                                %                               Next time, next line

} def

(This) (paragraph) (should) (be) (indented,) (meaning) (the) (first) (line) (is) (spaced) (out) (from) (the) (margin;)
(and) (justified,) (meaning) (the) (ends) (of) (lines) (line) (up) (together) (on) (the) (margin) (--) (quite) (like) (the) (beginnings) (--) (except) (the) (final) (line,) (unless) (it) (just) (happens) (to) (be) (the) (right) (length.)
(There) (should) (also) (be) (leading,) (or) (spacing) (between) (each) (line,) (and) (in) (this) (case) (it) (should) (be) (fifteen) (percent) (of) (the) (font) (height.)

/first true def                                                 % (word1)..(wordX)              This is the first line
{

    first CalcLine                                              % (wordN+1)..(wordX) (word1)..(wordN) N width final                     Calculate a line
    dup not exch first exch                                     % (wordN+1)..(wordX) (word1)..(wordN) N width justify indent final      Set up printing parameters and condition
    { PrintLine exit } if                                       % (wordN+1)..(wordX) (word1)..(wordN) N width justify                   If this is the last line, print it and we're done
    PrintLine                                                   % (wordN+1)..(wordX)                                                    Otherwise, print it and continue

    /first false def                                            % (wordN+1)..(wordX)            This isn't the first line

} loop

showpage
