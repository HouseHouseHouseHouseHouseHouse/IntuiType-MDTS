%!PS-Adobe-2.0

% Convert Inches to Points
% in --> pt
/in { 72 mul } def

/PageWidth 8.5 in def
/PageHeight 11 in def

/MarginX 1 in def
/MarginY 1 in def
/Indent 0.5 in def
/PaddingX 0 in def

/DefaultFontFace /Times-Roman def
/FontHeight 12 def
/Leading 0.15 def

/ColumnPortions [ 1 1 ] def
/Gutter 0.5 in def

/pageLine 0 def
/pageColumn 0 def

% TODO - Additional Formatting Things - Code Blocks etc.
% TODO - Auto-Break a Word that's Too Long
% TODO - Higher-Order Indentation (use integer as indent parameter)

% TODO (maybe) - Space out Err throughout All Chars (single-word lines)
% TODO (maybe) - Special Things for Dashes and other Word Separators
% TODO (maybe) - Font Colour?

% TODO - Make a Program to Generate this Document from Plaintext (maybe keep in res/ but no example, use fancy comments)

% Get Position and Width of Current Line
% - --> width x y
/Line {

    % This part finds the width of each portion of column distribution
    PageWidth MarginX 2 mul sub                                     % available                     Total space between margins
    ColumnPortions length 1 sub Gutter mul sub                      % available                     Account for gutters
    ColumnPortions aload pop                                        % available ptn..               All portion values
    ColumnPortions length 1 sub { add } repeat                      % available ptns                Sum them up
    div                                                             % ptnWidth                      Width of each portion

    % This part finds the width of the line
    ColumnPortions pageColumn get                                   % ptnWidth curPtns              Portions in current column
    1 index mul                                                     % ptnWidth width                Width of current column
    PaddingX 2 mul sub                                              % ptnWidth width                Account for padding

    % This part finds the X-value of the start of the line
    0 0 1 pageColumn 1 sub { ColumnPortions exch get add } for      % ptnWidth width lPtns          Total portions in columns to the left
    2 index mul pageColumn Gutter mul add MarginX add               % ptnWidth width x              X-value of column (add columns and gutters to the left)
    PaddingX add                                                    % ptnWidth width x              Account for padding

    3 -1 roll pop                                                   % width x

    % This part finds the Y-value of the line
    PageHeight MarginY sub pageLine                                 % width x top line              Top margin and line number
    FontHeight Leading 1 add mul                                    % width x top line spacing      Spacing per line
    mul FontHeight add sub                                          % width x y                     Pointer is at bottom of line

} def

% Advance to Next Line/Column/Page
/NextLine {

    /pageLine pageLine 1 add def                                    %                               Next line

    Line MarginY lt                                                 % width x overflow              Is this line in the bottom margin?
    { NextColumn } if                                               % width x                       If so, next column

    pop pop                                                         %

} def

% Advance to Next Column/Page
/NextColumn {

    /pageLine 0 def                                                 %                               Reset line
    /pageColumn pageColumn 1 add def                                %                               Next column

    pageColumn ColumnPortions length eq                             % pageFull                      Are we out of columns?
    { NextPage } if                                                 %                               If so, next page

} def

% Advance to Next Page
/NextPage {

    /pageLine 0 def                                                 %                               Reset line
    /pageColumn 0 def                                               %                               Reset column
    showpage                                                        %                               Next page

} def

% Calculate a Line of Words
% BASE [/f] (word1)..[/f] (wordX) indent --> BASE [/f] (wordN+1)..[/f] (wordX) /f (word1)../f (wordN) N width final
%
% The entire stack should be the remaining words in a paragraph,
% starting at the base, with optional font names below each
% word. Words that will fit in one line will be placed at the
% top and a font name will be specified for each.
/CalcLine {

                                                                % [/f] (word1)..[/f] (wordX) indent
    /curLineWidth 0 def                                         % [/f] (word1)..[/f] (wordX) indent     If a word fits, the total width is here
    /nxtLineWidth 0 def                                         % [/f] (word1)..[/f] (wordX) indent     Used to check if a word will fit with previous whitespace
    /curLineWords 0 def

    /maxLineWidth Line pop pop                                  % [/f] (word1)..[/f] (wordX) indent /v width        Maximum line width
    2 index { Indent sub } if def pop                           % [/f] (word1)..[/f] (wordX)                        Account for indent if necessary

    0                                                           % [/f] (word1)..[/f] (wordX) 0      Mark the end of the paragraph

    {

        % This part checks what's next, it may not be a word
        /final true def                                         % [/f] (cur)../f (pre)              If we exit, this is the final line

        count -1 roll                                           % ../f (pre) [(cur) OR /f OR 0]     Bring up current word, next font name, or end mark

        dup 0 eq { count 1 roll exit } if                       % ../f (pre) [(cur) OR /f]          If this is the end mark, replace it and exit

        dup type /nametype eq {
                                                                % (cur) [/f] (nxt)../f (pre) /f
            /curFontFace exch def                               % (cur) [/f] (nxt)../f (pre)        If this is a font name, set variable
            count -1 roll                                       % [/f] (nxt)../f (pre) (cur)        Bring up current word
        } if
        curFontFace exch                                        % [/f] (nxt)../f (pre) /f (cur)     Bury current font for print routine

        % This part checks if the word will fit in the line
        /final false def                                        % [/f] (nxt)../f (cur)              If we exit, this isn't the final line

        curFontFace findfont FontHeight scalefont setfont       % [/f] (nxt)../f (cur)              Set word font
        dup stringwidth pop nxtLineWidth add                    % [/f] (nxt)../f (cur) width        Width of line including this word
        dup maxLineWidth gt { pop count 2 roll exit } if        % [/f] (nxt)../f (cur) width        If word doesn't fit, stop here
        /curLineWidth exch def                                  % [/f] (nxt)../f (cur)              Otherwise, add to width
        /curLineWords curLineWords 1 add def                    % [/f] (nxt)../f (cur)              Increment word counter

        % This part checks if whitespace will fit in the line
        /nxtLineWidth ( ) stringwidth pop curLineWidth add def  % [/f] (nxt)../f (cur)              Width of line including this word with whitespace
        nxtLineWidth maxLineWidth ge { exit } if                % [/f] (nxt)../f (cur)              If whitespace doesn't fit, stop here

    } loop

                                                                % [/f] (wordN+1)..[/f] (wordX) 0 /f (word1)../f (wordN)
    curLineWords 2 mul 1 add -1 roll pop                        % [/f] (wordN+1)..[/f] (wordX) /f (word1)../f (wordN)
    curLineWords curLineWidth final                             % [/f] (wordN+1)..[/f] (wordX) /f (word1)../f (wordN) N width final

} def

% Print a Line of Words 
% /f (word1)../f (wordN) N width justify align indent --> -
%
% The stack should contain a font name for every word in the line.
% All words will be printed onto the current line, and the line will
% be advanced.
/PrintLine {

    % This part calculates the remaining space in the line      % /f (word1)../f (wordN) N width justify align indent
    4 -1 roll                                                   % /f (word1)../f (wordN) N justify align indent width
    Line pop pop                                                % /f (word1)../f (wordN) N justify align indent width maxWidth      Maximum line width
    2 index { Indent sub } if                                   % /f (word1)../f (wordN) N justify align indent width maxWidth      Account for indent if necessary
    exch sub                                                    % /f (word1)../f (wordN) N justify align indent balance             Amount of space remaining
    4 -2 roll exch                                              % /f (word1)../f (wordN) N indent balance align justify

    % This part calculates the err for justifying
    /err 0 def
    /charErr 0 def
    {
                                                                % /f (word1)../f (wordN) N indent balance align
        pop 2 index                                             % /f (word1)../f (wordN) N indent balance N
        dup 1 ne                                                % /f (word1)../f (wordN) N indent balance N plural      Is there more than one word in this line?
        {
            1 sub div                                           % /f (word1)../f (wordN) N indent err                   If so, calculate points to add to whitespace
            /err exch def                                       % /f (word1)../f (wordN) N indent
        } {
            pop 4 index length                                  % /f (word1)../f (wordN) N indent chars                 Otherwise, number of chars in word
            1 sub div                                           % /f (word1)../f (wordN) N indent charErr               Calculate points to add to each char
            /charErr exch def                                   % /f (word1)../f (wordN) N indent
        } ifelse

        Line 3 -1 roll pop                                      % /f (word1)../f (wordN) N indent x y                   Use default X-value to start at left margin

    }

    % This part calculates the offset for aligning
    {

                                                                % /f (word1)../f (wordN) N indent balance align
        2 div mul                                               % /f (word1)../f (wordN) N indent offset                Offset to align to the right side
        Line exch 4 -2 roll pop                                 % /f (word1)../f (wordN) N indent y x offset            Default X-value
        add exch                                                % /f (word1)../f (wordN) N indent x y                   Add offset to align properly

    } ifelse                                                    % /f (word1)../f (wordN) N indent x y

    % This part positions the pointer
    3 1 roll exch { Indent add } if exch                        % /f (word1)../f (wordN) N x y                          Account for indentation if necessary
    moveto                                                      % /f (word1)../f (wordN) N                              Move pointer

    % This part prints each word
    -1 1 {

                                                                % /f (cur)../f (wordN) i                i = words remaining
        dup 2 mul 1 add -2 roll                                 % /f (nxt)../f (wordN) i /f (cur)       Bring up current word or next font name
        exch findfont FontHeight scalefont setfont              % /f (nxt)../f (wordN) i (cur)          Set word font
        charErr exch 0 exch ashow                               % /f (nxt)../f (wordN) i                Print current word with any char err

        1 gt { err 0 ( ) ashow } if                             % /f (nxt)../f (wordN)                  If there are more words, print whitespace with extra points

    } for                                                       %                                   Loop through all words

    NextLine                                                    %                                   Next line/column/page

} def

% Print a Paragraph
% BASE /f (word1) [/f] (word2)..[/f] (wordX) -> BASE -
%
% The stack should consist of only the words in the paragraph.
% Words are individual strings optionally preceded by a font
% name. The first word is at the base of the stack and it must
% have a font name.
/PrintParagraph {

    /PaddingX 0 in def                                          % /f (word1)..[/f] (wordX)          No padding

    /first true def                                             % /f (word1)..[/f] (wordX)          This is the first line
    {

        first CalcLine                                          % [/f] (wordN+1)..[/f] (wordX) /f (word1)../f (wordN) N width final                             Calculate a line
        dup not 0 first 4 -1 roll                               % [/f] (wordN+1)..[/f] (wordX) /f (word1)../f (wordN) N width justify align indent final        Set up printing parameters and condition
        { PrintLine exit } { PrintLine } ifelse                 % [/f] (wordN+1)..[/f] (wordX)                                                                  Print line, exit if we're done

        /first false def                                        % [/f] (wordN+1)..[/f] (wordX)      This isn't the first line

    } loop

    NextLine                                                    %                                   Skip a line between paragraphs

} def

% Print a Paragraph with Alignment
% BASE /f (word1) [/f] (word2)..[/f] (wordX) indent align -> BASE -
%
% Alignment is specified using an integer. 0 means left-align,
% 1 means centre-align, and 2 means right-align.
/PrintParagraphAligned {

    /PaddingX 0 in def                                          % /f (word1)..[/f] (wordX) align        No padding
    /align exch def                                             % /f (word1)..[/f] (wordX)              Set variable

    /indent exch def                                            % /f (word1)..[/f] (wordX)          Indent the first line if necessary
    {

        indent CalcLine                                         % [/f] (wordN+1)..[/f] (wordX) /f (word1)../f (wordN) N width final                             Calculate a line
        false align indent 4 -1 roll                            % [/f] (wordN+1)..[/f] (wordX) /f (word1)../f (wordN) N width justify align indent final        Set up printing parameters and condition
        { PrintLine exit } { PrintLine } ifelse                 % [/f] (wordN+1)..[/f] (wordX)                                                                  Print line, exit if we're done

        /indent false def                                       % [/f] (wordN+1)..[/f] (wordX)      Don't indent subsequent lines

    } loop

    NextLine                                                    %                                   Skip a line between paragraphs

} def


% Print a Block-Quote
% BASE /f (word1) [/f] (word2)..[/f] (wordX) -> BASE -
/PrintBlockQuote {

    /PaddingX Indent def                                        % /f (word1) [/f] (word2)..[/f] (wordX)     Pad by the indentation amount

    {

        false CalcLine                                          % [/f] (wordN+1)..[/f] (wordX) /f (word1)../f (wordN) N width final                             Calculate a line
        dup not 0 false 4 -1 roll                               % [/f] (wordN+1)..[/f] (wordX) /f (word1)../f (wordN) N width justify align indent final        Set up printing parameters and condition
        { PrintLine exit } { PrintLine } ifelse                 % [/f] (wordN+1)..[/f] (wordX)                                                                  Print line, exit if we're done

    } loop

    NextLine                                                    %                                   Skip a line

} def

% Print a List Item
% BASE /f (word1) [/f] (word2)..[/f] (wordX) index -> BASE -
/PrintListItem {

    /PaddingX 0 in def                                          % /f (word1) [/f] (word2)..[/f] (wordX)             No padding

    Line moveto pop                                             % /f (word1) [/f] (word2)..[/f] (wordX) index       Move pointer to current line
    DefaultFontFace findfont FontHeight scalefont setfont       % /f (word1) [/f] (word2)..[/f] (wordX) index       Set default font
    (  ) cvs show (.) show                                      % /f (word1) [/f] (word2)..[/f] (wordX)             Print index

    {

        true CalcLine                                           % [/f] (wordN+1)..[/f] (wordX) /f (word1)../f (wordN) N width final                             Calculate a line
        dup not 0 true 4 -1 roll                                % [/f] (wordN+1)..[/f] (wordX) /f (word1)../f (wordN) N width justify align indent final        Set up printing parameters and condition
        { PrintLine exit } { PrintLine } ifelse                 % [/f] (wordN+1)..[/f] (wordX)                                                                  Print line, exit if we're done

    } loop

    NextLine                                                    %                                   Skip a line

} def

% Print a Rule
/PrintRule {

    /PaddingX Indent 2 div def                                  %                                   Pad by half the indentation amount

    newpath                                                     %                                   New path

    Line moveto                                                 % width                             Move pointer to current line
    0 FontHeight 2 div rmoveto                                  % width                             Centre of line
    0 rlineto                                                   %                                   Symmetric rule

    gsave                                                       %                                   Save Graphics Context

    0.5 setgray 2 setlinewidth 2 setlinecap                     %                                   Grey, 2 pt line, square cap
    stroke                                                      %                                   Draw

    grestore                                                    %                                   Restore Graphics Context

    NextLine                                                    %                                   Don't use this line

} def

/Times-Roman (The) (first) (line) (of) (this) (paragraph) (should) (be) /Times-Bold (indented,) /Times-Roman (meaning) (there) (is) (space) (between) (the) (left) (margin) (and) (the) (type,)
(which) (in) (this) (case) (it) (should) (be) /Times-Italic (one) (inch) /Times-Roman (of) (space.)
(This) (paragraph) (should) (be) /Times-Bold (justified,) /Times-Roman (meaning) (the) (left) (side) (of) (the) (is) (flush) (with) (the) (left) (margin,) (and) (the) (right) (side) (is) (flush) (with) (the) (right) (margin,)
(except) (the) (final) (line,) (unless) (it) (just) (happens) (to) (be) (the) (right) (length.)
(There) (should) (also) (be) /Times-Bold (leading,) /Times-Roman (or) (space) (between) (each) (line,) (and) (in) (this) (case) (it) (should) (be) /Times-Italic (fifteen) (percent) /Times-Roman (of) (the) (font) (height.)

PrintParagraph

/Times-Roman (Here) (is) (another) (paragraph.)
(There) (should) (be) (one) (line's) (worth) (of) (space) (between) (this) (and) (the) (previous) (paragraph.)
(Paragraph) (spacing) (is) (used) (in) (addition) (to) (indentation) (to) (emphasize) (the) (change) (in) (subject) (matter) (between) (paragraphs.)

PrintParagraph

PrintRule

/Times-Roman (This) (paragraph) (should) (be) /Times-Bold (left-aligned,) /Times-Roman (meaning) (the) (left) (side) (of) (the) (paragraph) (is) (flush) (with) (the) (left) (margin,) (and) (nothing) (else.)
(This) (means) (that) (the) (right) (side) (of) (the) (paragraph) (is) (uneven,) (or) /Times-Bold (ragged.) /Times-Roman
(This) (is) (how) (one) (typically) (writes) (a) (paragraph,) (and) (how) (most) (style) (guides) (suggest) (a) (paragraph) (be) (typeset.)

true 0 PrintParagraphAligned

/Times-Roman (This) (paragraph) (should) (be) /Times-Bold (right-aligned.) /Times-Roman
(The) (right) (side) (of) (the) (paragraph) (is) (flush) (with) (the) (right) (margin,) (and) (the) (left) (side) (is) (ragged.)
(Because) (of) (the) (latter) (detail,) (and) (since) (it) (wouldn't) (be) (consistent,) (the) (first) (line) (of) (this) (paragraph) (is) (not) (indented.)
(Paragraphs) (typically) (are) (not) (aligned) (this) (way) (as) (it) (makes) (it) (harder) (to) (start) (reading) (the) (next) (line.)

false 2 PrintParagraphAligned

/Times-Roman (This) (paragraph) (should) (be) /Times-Bold (centre-aligned,) /Times-Roman (meaning) (each) (line) (is) (horizontally) (centred) (on) (the) (page.)
(Both) (sides) (of) (the) (paragraph) (are) (ragged.)
(This) (is) (used) (sometimes) (for) (headings) (and) (titles,) (and) (not) (for) (paragraphs.)

false 1 PrintParagraphAligned

PrintRule

/Times-Roman (This) (paragraph) (should) (overflow) (into) (the) (right-hand) (column.)
(Separating) (the) (columns) (should) (be) (a) /Times-Bold (gutter,) /Times-Roman (which) (is) (a) (bit) (of) (horizontal) (spacing,)
(and) (in) (this) (case) (it) (should) (be) /Times-Italic (half) (an) (inch) /Times-Roman (wide.)
(Sometimes) (you) (will) (see) (lines) (separating) (columns) (instead,) (and) (those) (are) (called) /Times-Bold (rules.) /Times-Roman
(In) (fact,) (a) (horizontal) (rule) (should) (be) (between) (this) (paragraph) (and) (the) (previous) (one.)

PrintParagraph

PrintRule

/Times-Roman (This) (is) (the) (first) (item) (in) (a) (list.)
(It) (should) (be) (preceded) (by) (the) (number) (one,) (and) (every) (line) (should) (be) (indented.)

1 PrintListItem

/Times-Roman (This) (is) (the) (second) (item) (in) (a) (list.)
(Lists) (like) (these) (are) (generally) (used) (in) (memorandums) (for) (brevity) (and) (ease) (in) (reading.)

2 PrintListItem

/Times-Roman (This) (is) (the) (third) (item) (in) (a) (list.)
(Three) (is) (generally) (the) (minimum) (number) (of) (items) (in) (a) (list,) (as) (having) (fewer) (items) (will) (make) (the) (writing) (simple) (enough) (to) (be) (understood) (without) (the) (context) (of) (one.)

3 PrintListItem

/Times-Roman (This) (is) (a) /Times-Bold (block-quote.) /Times-Roman
(The) (paragraph) (should) (be) (justified,) (and) (every) (line) (should) (be) (indented) (from) (both) (the) (left) (and) (the) (right,) (making) (the) (paragraph) (horizontally) (condensed.)
(Block-quotes) (are) (generally) (used) (when) (a) (quote) (or) (excerpt) (is) (four) (lines) (or) (more.)

PrintBlockQuote

PrintRule

/Times-Roman (This) (paragraph) (is) (too) (long) (to) (be) (kept) (on) (this) (page,) (so) (it) (should) (overflow) (into) (another) (one.)
(If) (you're) (viewing) (this) (in) (a) (document) (reader) (or) (previewer,) (Evince) (for) (instance,)
(you) (may) (notice) (that) (there) (is) (only) (one) (page,) (and) (that) (this) (paragraph) (starts) (rather) (abruptly,) (without) (indentation.)
(This) (is) (because) (those) (programs) (are) (expecting) (special) (comments) (with) (the) (page) (count) (and) (numbering.)
(Programs) (like) (GhostScript,) (however,) (render) (this) (document) (perfectly) (fine.)
(Also,) (utilities) (like) (PS2PDF) (will) (convert) (this) (document) (to) (PDF,) (and) (document) (readers) (will) (render) (it) (well.)

PrintParagraph

showpage
